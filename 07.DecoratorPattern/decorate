****** 07.데코레이터 패턴 ******

* 객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주는 패턴
- 기본 기능에 추가할 수 있는 기능의 종류가 많은 경우에 각 추가 기능을 Decorator 클래스로 정의한 후
  필요한 Decorator 객체를 조합함으로써 추가 기능의 조합을 설계하는 방식
- ex) 기본 도로 표시 기능에 차선 표시, 교통량 표시, 교차로 표시, 단속 카메라 표시의 4가지 추가 기능이 있을 때
      추가 기능의 모든 조합은 15가지가 된다.
- 데코레이터 패턴을 이용하여 필요 추가 기능의 조합을 동적으로 생성할 수 있다.

- 상속을 통해 확장을 할 수 있지만, 상속은 디자인 유연성 면에서는 별로 좋지 않다.
- 기존 코드를 수정하지 않고도 행동을 확장하는 방법이 필요하다.
- 상속 대신 데코레이터 패턴을 통해서 행동을 확장할 수 있다.

* 데코레이터가 적용된 예 : 자바 입출력의 필터 스트림
- 기반 스트림과 보조스트림을 데코레이터 패턴을 배우고 다시 정리해보면 많은 클래스들이 좀 더 쉽게 다가온다.

BufferedReader br = null;
try{
    br = new BufferedReader(new FileReader(new File("test.txt")));
} catch(Exception e){
    e.printStackTrace();
}

* 데코레이터 패턴의 단점
1. 데코레이터 패턴을 사용하면 자잘한 객체들이 매우 많이 추가될 수 있고, 데코레이터를 너무 많이 사용하면 코드가 필요 이상으로 복잡해질 수도 있다.
2. 구성요소(Component)를 초기화하는 데 필요한 코드가 훨씬 복잡해진다.
   구성요소(Component) Instance 만 만든다고 해서 일이 끝나는게 아니라 많은 데코레이터로 Wrapping 해야 하는 경우가 있다.
   그래서 데코레이터 패턴이나 빌더 패턴과 함께 사용된다
3. 데코레이터 패턴은 구상 구성요소(Concrete Component)의 형식을 알아내서 그 결과를 바탕으로
   어떤 작업을 처리하는 코드(특정 형식에 의존하는 클라이언트 코드)에는 적용할 수 없다.
   기존의 구성요소 HouseBlend 였을 때 기존의 구성요소를 데코레이터로 감싸게 되면, 그 구성요소가 HouseBlend 인지 아닌지 알 수가 없게 된다.